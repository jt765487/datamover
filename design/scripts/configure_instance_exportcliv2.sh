#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# -----------------------------------------------------------------------------
# Simple Instance Configurator
# -----------------------------------------------------------------------------
# - Creates or copies /etc/<app>/<instance>.conf
# - Prints exactly which systemctl/journalctl commands to run next
# -----------------------------------------------------------------------------

# --- Logging Helpers ---
_ts()   { date -u +'%Y-%m-%dT%H:%M:%SZ'; }
info()  { echo "$(_ts) [INFO]  $*"; }
warn()  { echo "$(_ts) [WARN]  $*"; }
error_exit() { echo "$(_ts) [ERROR] $*" >&2; exit 1; }

# --- Defaults & CLI State ---
DRY_RUN=""                       # if set to 'echo', commands are printed
INSTANCE=""                      # name of this instance
CONFIG_SRC=""                    # optional user-provided conf

# Base‐vars lookup (must match your base installer)
APP_NAME_FOR_BASE_VARS="exportcliv2"
BASE_VARS_FILE="/etc/default/${APP_NAME_FOR_BASE_VARS}_base_vars"

# Defaults for generated configs
DEFAULT_EXPORT_TIMEOUT="60"
DEFAULT_EXPORT_IP="10.0.0.1"
DEFAULT_EXPORT_PORTID="1"
DEFAULT_EXPORT_START_DATE="today"
DEFAULT_EXPORT_START_TIME="00:00"
DEFAULT_EXPORT_END_DATE="today"
DEFAULT_EXPORT_END_TIME="23:59"

usage() {
  cat <<EOF
Usage: $0 -i INSTANCE_NAME [--config-source-file PATH] [-n] [-h]

  -i, --instance NAME       REQUIRED: this instance’s name (e.g. "lab1")
  --config-source-file PATH Optional: copy this file instead of generating defaults
  -n, --dry-run             Print actions instead of executing
  -h, --help                Show this message and exit
EOF
  exit 1
}

# --- Parse args ---
while [[ $# -gt 0 ]]; do
  case $1 in
    -i|--instance)
      INSTANCE="$2"; shift 2 ;;
    --config-source-file)
      CONFIG_SRC="$2"; shift 2 ;;
    -n|--dry-run)
      DRY_RUN="echo"; shift ;;
    -h|--help)
      usage ;;
    *)
      error_exit "Unknown option: $1";;
  esac
done
[[ -n "$INSTANCE" ]] || error_exit "Instance name is required (-i)."

# --- Load Base Vars ---
[[ -f "$BASE_VARS_FILE" ]] \
  || error_exit "Base-vars file '$BASE_VARS_FILE' not found. Run base installer first."
info "Sourcing base-vars from $BASE_VARS_FILE"
# shellcheck source=/dev/null
source "$BASE_VARS_FILE"

# Validate what we got from base-vars
: "${APP_NAME:?ERROR: APP_NAME not set in base-vars}"
: "${ETC_DIR:?ERROR: ETC_DIR not set in base-vars}"           # e.g. /etc/exportcliv2
: "${APP_GROUP:?ERROR: APP_GROUP not set in base-vars}"

TARGET_CONF="${ETC_DIR}/${INSTANCE}.conf"

# --- Ensure config dir exists ---
info "Ensuring config directory: $ETC_DIR"
$DRY_RUN install -d -o root -g root -m0755 "$ETC_DIR"

# --- Deploy or Generate ---
if [[ -n "$CONFIG_SRC" ]]; then
  [[ -f "$CONFIG_SRC" ]] \
    || error_exit "Config source '$CONFIG_SRC' not found."
  info "Copying $CONFIG_SRC → $TARGET_CONF"
  $DRY_RUN install -T -o root -g "$APP_GROUP" -m0640 \
    "$CONFIG_SRC" "$TARGET_CONF"
else
  info "Generating default configuration in $TARGET_CONF"
  # resolve "today"
  today=$(date +%Y-%m-%d)
  sd=${DEFAULT_EXPORT_START_DATE//today/$today}
  ed=${DEFAULT_EXPORT_END_DATE//today/$today}

  read -r -d '' CONTENT <<EOF || true
# ${APP_NAME} instance '${INSTANCE}'
# Generated by $0 on $(_ts)

EXPORT_TIMEOUT="${DEFAULT_EXPORT_TIMEOUT}"
EXPORT_SOURCE="${INSTANCE}"

# Optional (defaults shown)
EXPORT_IP="${DEFAULT_EXPORT_IP}"
EXPORT_PORTID="${DEFAULT_EXPORT_PORTID}"
EXPORT_STARTTIME="${sd}/${DEFAULT_EXPORT_START_TIME}"
EXPORT_ENDTIME="${ed}/${DEFAULT_EXPORT_END_TIME}"
EOF

  if [[ -n "$DRY_RUN" ]]; then
    echo "[DRY_RUN] Would write:"
    echo "$CONTENT"
  else
    printf "%s\n" "$CONTENT" > "$TARGET_CONF"
    chmod 0640 "$TARGET_CONF"
    chown root:"$APP_GROUP" "$TARGET_CONF"
  fi
fi

# --- Next Steps ----
info "Configuration ready: $TARGET_CONF"

cat <<EOF

To manage your instance with systemd:
-------------------------------------
Enable at boot:
  sudo systemctl enable ${APP_NAME}@${INSTANCE}.service
  sudo systemctl enable ${APP_NAME}-restart@${INSTANCE}.path

Start now:
  sudo systemctl start ${APP_NAME}@${INSTANCE}.service

Stop:
  sudo systemctl stop ${APP_NAME}@${INSTANCE}.service

Restart:
  sudo systemctl restart ${APP_NAME}@${INSTANCE}.service

Status:
  sudo systemctl status ${APP_NAME}@${INSTANCE}.service

Logs (last 50 lines):
  sudo journalctl -u ${APP_NAME}@${INSTANCE}.service -n50

Follow logs:
  sudo journalctl -u ${APP_NAME}@${INSTANCE}.service -f
-------------------------------------
EOF

exit 0
